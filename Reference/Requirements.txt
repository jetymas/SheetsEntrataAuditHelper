Chrome Extension for Lease Audit Automation – Requirements Specification
Introduction
On-site staff at apartment communities routinely conduct lease audits to ensure that the details in signed lease agreements match the data entered into property management systems. This specification describes a Chrome Extension designed to automate the lease audit process for properties using the Entrata platform in conjunction with Google Sheets. The extension streamlines verification of lease data by automatically retrieving information from Entrata's web interface and comparing it against an audit spreadsheet, thereby reducing manual effort and errors. The system operates entirely via browser automation (no direct Entrata API usage) and integrates with Google Sheets through the Google Sheets API. A focus is placed on security (no long-term storage of sensitive data) and ease of use for non-technical staff.
Modular Audit Engine Architecture
To maximize maintainability and reuse, the extension is built around a modular instruction engine. Each type of lease audit is encapsulated in its own JavaScript class, and each auditable spreadsheet column is handled by a dedicated module. This architecture allows the extension to support multiple audit types (e.g. initial lease audits, renewal audits) and to share common verification logic across them.
Audit Type Classes: Every audit type (such as a Lease Audit or Renewal Audit) is implemented as a separate class. These classes define the high-level workflow for that audit type and expose a standard interface:
setUp() – Prepares the Entrata environment for the audit. This may include opening required Entrata pages or pop-up windows and applying any search filters or sorting. For example, setUp() might navigate directly to the Entrata residents listing page and ensure records are sorted alphabetically by resident name (first name + last name) to maintain a consistent audit order.
findNext() – Locates and opens the next resident record in Entrata corresponding to the next unverified row in the Google Sheet. This method reads the Google Sheet to identify the next row that still has unchecked fields, then searches the Entrata interface for the matching resident. If the current Entrata results page has been exhausted, findNext() will automatically click the "Next" button to load further results. In effect, this function navigates through Entrata’s paginated resident directory to ensure each resident from the sheet is found in turn.
nextField() – Determines which field (spreadsheet column) to verify next for the current resident. If there are remaining unchecked checkbox columns for the active spreadsheet row, this method returns the next column’s letter (identifier). The extension will then invoke the corresponding column module to handle the verification of that field. If no unverified fields remain for the current row, nextField() indicates that the audit should proceed to the next resident (triggering findNext() for the following record).
Column Modules: Each auditable column in the Google Sheet is implemented as a reusable module, stored in its own JavaScript file (named after the column letter it handles). Column modules encapsulate the logic for verifying a specific type of data:
run(row, col, context) – Performs the audit check for its column on the given sheet row. The extension will call this method when a particular field needs verification. The module’s logic will use the provided context (which includes references to the Entrata page or data, such as the currently open resident record or lease document) to locate the relevant information. For example, a module for Lease Start Date (say, Column K) might locate and open the resident’s signed lease PDF, search within the document for the term "Start Date", extract the date value, and compare it to the date present in the Google Sheet cell for that row and column. If the values do not match, or if any ambiguity arises, the module can trigger a confirmation prompt for the user. The run method is responsible for any on-screen navigation needed to retrieve the data (such as clicking to view a lease document or scrolling within a PDF) and for initiating the comparison.
displayData(row, col, context) – Prepares data for user display after or during the run execution. This function returns the key pieces of information needed to present a side-by-side comparison of the spreadsheet value vs. the lease value in the extension’s UI. For instance, after the Lease Start Date module finds the date in the PDF and reads the date from the Google Sheet, displayData might return an object containing the two date values (and possibly field labels or context) so that the extension can show a popup dialog or interface section where the Sheet value and Entrata value are placed next to each other for the user to review.
The audit type classes orchestrate the overall process, calling findNext() to move through records and nextField() / column modules to handle each data point. This modular design ensures that the logic for each field (column) is defined in one place and can be reused across different audits. For example, a “Renewal Audit” class can utilize the same column modules for common fields like lease dates or rent amounts that the “Lease Audit” class uses, avoiding duplicate code.
User Interface and Configuration
All user-facing controls are provided via the extension’s popup interface (the UI that appears when the extension icon is clicked). The design emphasizes simplicity so that staff can easily configure and run audits without technical knowledge.
Audit Type Selection: The popup includes a dropdown menu or selection control for the user to choose the type of audit to perform (e.g. Lease Audit, Renewal Audit, etc.). The selected audit type determines which Audit Type Class and set of column checks will be used during the run. This makes the extension flexible – new audit types can be introduced in the future by adding a new class and listing it in the UI, without changing the core logic.
Google Sheet URL Input: The popup UI provides a text input field where the user enters or pastes the URL (or ID) of the Google Sheets audit template. This is required at the start of each audit session. The sheet URL is session-scoped only – it is not saved between extension sessions for security and consistency reasons. Staff will input the link every time they start a new audit run. Once provided, the extension will use this to fetch and update data via the Google Sheets API.
Control Buttons: The popup includes a button to Start the audit after the user has selected an audit type and entered the Google Sheet URL. There may also be a Stop button or the ability to pause/terminate the run if needed (especially in case the user wants to abort mid-way; see error handling for how the extension handles unexpected stops). In v1, there is no dedicated “Pause” or advanced run control beyond simply stopping, as a post-run summary or resume functionality is out of scope.
Real-time Audit Display: As the audit progresses, the extension popup serves as a status display and interaction point for each field verification. When the extension is ready to verify a particular field, the popup will present the data returned from the displayData method – typically showing the value from the Google Sheet alongside the corresponding value extracted from Entrata (or the lease PDF). This side-by-side presentation allows the user to easily compare the two. For example, the popup might show Sheet Lease Start Date: 01/01/2024 next to Lease PDF Start Date: 01/02/2024. The user can then confirm whether they match or flag a discrepancy.
Confirmation and Skip Options: For each field comparison shown, the UI will likely provide options such as “Mark as Verified” (if the values match or the user deems them correct) or “Skip/Flag” (if the field cannot be verified or needs manual review). Marking as verified will cause the extension to check the corresponding checkbox in the Google Sheet for that field, whereas skipping will leave it unchecked but record a comment (to note that it was skipped or needs attention). These interactions are recorded immediately via the Sheets API. The extension’s design is user-driven at each step to ensure any ambiguities are resolved with human judgment.
In summary, the popup interface not only gathers initial configuration (audit type and sheet URL) but also guides the user through the audit, showing relevant information and receiving user decisions (confirmations or skips) for each data field.
Audit Execution Workflow
Once configured, the extension executes the audit in a step-by-step sequence. The workflow below outlines how the process unfolds for each resident record and each field:
Initialization: The user clicks Start in the popup to begin the audit. The extension reads the provided Google Sheet URL and establishes a connection to the Google Sheet (e.g. using the Sheets API) to read data and update cells. The selected Audit Type Class is instantiated. The extension then invokes the audit class’s setUp() method to prepare the Entrata environment:
The extension opens a new browser tab (or navigates the current one) to the Entrata residents page for the property, using the direct URL https://preiss.entrata.com/?module=customers_systemxxx. This bypasses any need for the user to manually navigate through Entrata’s menus.
In Entrata, the extension ensures the resident records are filtered and sorted appropriately. For example, it may apply a filter to show only active leases if the audit is for current leases, and sort the list alphabetically by resident name. (Entrata’s interface might require clicking a column header or using a filter dropdown—these actions would be handled in setUp().)
Any additional windows or panels that will be needed are also opened at this time. For instance, if Entrata normally opens lease documents in a pop-up window or separate frame, setUp() might handle pre-authorizing pop-ups or setting up the UI so that opening a PDF is seamless during the audit.
Navigate to First Record: With the environment ready, the extension calls the audit class’s findNext() method to locate the first resident record to audit. findNext() consults the Google Sheet to find the first data row (below the header, which is known to be on row 8 of the sheet) that has unverified fields (unchecked boxes). It then uses identifying information from that row (for example, the resident’s name or apartment number, depending on what is available in the sheet) to search the Entrata resident list. This could involve typing the resident’s name into Entrata’s search bar or scanning the list of names on the current page.
If the resident is found on the current page of results, the extension clicks on that resident’s entry to open their profile or lease details.
If the resident is not on the current page (Entrata paginates the resident list), the extension will click the “Next” button in Entrata to load the next page of results and then continue the search. This page advancement continues until the resident is found or the list is exhausted.
In the case where the list is exhausted (e.g., the Google Sheet has a resident that the Entrata search doesn’t find at all), the extension will recognize that the resident was not located. In v1, the likely approach is to flag this scenario to the user (perhaps by a popup message) and skip that row, since a missing resident could indicate a data issue outside the extension’s scope. The audit then proceeds to look for the next row’s resident.
Field-by-Field Verification: Once the extension has navigated to the Entrata record for the target resident, it begins verifying the fields for that resident one column at a time:
The audit class’s nextField() method is invoked to get the next unverified column for the current resident’s row in the Google Sheet. Suppose the first unverified column is Column J (Lease End Date). The extension will load the module corresponding to Column J and call its run(row, col, context) function, passing in references to the current sheet row and any contextual information (e.g., the Entrata page or document viewer).
Data Retrieval: The column module executes its run logic. For a field stored directly in Entrata’s web interface (such as a date or number shown on the resident’s profile page), this might involve scraping the text content of a specific field on the page. For a field that resides within a lease PDF document (such as a lease start date that’s only present on the signed lease PDF), the module will command the browser to open or focus the lease document. The extension will locate the lease document by looking for a file name or link that matches a known pattern. For example, to find a signed lease, it searches for a document whose name contains "* Lease – Signed" (with * being the property or resident identifier) as previously configured. It then opens this document in Entrata’s built-in PDF viewer.
Using Entrata’s PDF Viewer: If the field is within a PDF, the module takes advantage of Entrata’s native PDF text search capability. For example, the Column K module (which might correspond to Lease Start Date) will programmatically activate the search function in the PDF viewer to find the string "Start Date" or other relevant keywords near the value it needs. Entrata’s PDF viewer will highlight or navigate to the first occurrence of this term. The extension can then extract the text adjacent to that term (for instance, the date that follows "Start Date:") if the PDF’s text layer is available. If Entrata’s viewer does not expose text extraction to the extension, the module might alternatively rely on the visual highlight, using a heuristic or simply pausing to allow the user to see the highlighted term in the PDF.
Comparison: Once the target data is retrieved from Entrata (either from a web page field or from the PDF text), the module compares it with the expected value from the Google Sheet. This comparison could be a straightforward string or number equality check, or could involve some normalization (for example, date formats might need to be standardized before comparison).
Displaying Results: The extension then calls the module’s displayData(row, col, context) to gather the values for display. The extension’s popup UI will update to show the user the Sheet value vs. Entrata value for the field in question, side by side. Following our example, the popup might show something like:
Lease End Date – Sheet: 12/31/2024
Lease End Date – Entrata: 12/31/2024
If the values match exactly, the interface might visually indicate this (e.g., green highlight or a check mark), but still allow the user to confirm before proceeding. If the values differ, they might be highlighted in red, signaling a discrepancy that the user needs to resolve.
User Confirmation: The user reviews the side-by-side data in the popup. If everything looks correct (either the values match, or the difference is understood and acceptable), the user clicks the Mark as Verified (or equivalent) button for that field. At this point, the extension will check off the corresponding checkbox in the Google Sheet (marking that cell as verified) via the Google Sheets API. This update is performed immediately for that single cell (the extension does not batch updates, opting for a simple strategy of writing each change as it occurs).
If the user notices a discrepancy or if the extension was unable to automatically retrieve the field (for example, perhaps the PDF text couldn’t be read, or the value was not found), the user can choose to Skip/Flag that field. When skipping, the extension will leave that checkbox unchecked and optionally add a comment to that Google Sheet cell indicating it was skipped or requires manual verification. (The extension uses the Google Sheets API to add a cell comment with a note such as "Skipped by audit on [date]" or a reason if available. If the account running the extension doesn’t have permission to add comments or the comment fails to post, the extension will simply proceed without the comment and record the skip internally.)
In the event that the extension itself cannot proceed with a field due to an error (for instance, if the lease document did not load, or the expected text could not be found at all), it will prompt the user with a dialog explaining the issue. The user is given a choice: "Skip this Field" or "Stop the Audit". Skip will behave as described (log the issue, mark the field as needing manual attention, then continue with the next field or record), whereas Stop will terminate the entire audit run at that point, allowing the user to fix issues (like data entry errors, missing documents, etc.) before possibly restarting.
Iterating Through Fields: After one field is verified (or skipped), the extension calls nextField() again to get the next unverified column for the same resident. Steps 3-4 repeat for each relevant column in that row. During this phase, if the extension needs to open the lease PDF for multiple fields, it will typically reuse the already open document viewer to avoid redundant operations. Each column module may search for different terms within the PDF (e.g., one module searches "Start Date", another searches "End Date", another might search for "Rent $" for rent amount) as needed for its field.
Moving to Next Resident: Once all configured columns for the current resident’s row have been handled (all checkboxes verified or appropriately skipped/commented), the extension considers that resident audited. The audit class’s findNext() is called again to move to the next unverified row in the Google Sheet, which corresponds to the next resident. The Entrata interface might still be on the previous resident’s profile or document, so typically the extension will navigate back to the resident list or search results page. (In some implementations, it may keep the list open in one tab and open each resident’s detail in another tab or window for efficiency.) The next resident is found in the same manner as step 2, possibly continuing from the last position in the list.
The extension may also reset state as needed (for example, closing a PDF viewer from the prior resident if Entrata does not auto-close it, to avoid confusion).
setUp() is generally only called once at the beginning, so for each subsequent record, the extension relies on findNext() and the existing state (sorted list, etc.) to find residents.
Completion: The above cycle (steps 2–6) repeats until the Google Sheet has no more rows with unchecked fields (i.e., all necessary entries have been audited). At that point, the extension stops its automation. In v1, there is no post-run summary screen; the expectation is that the Google Sheet itself serves as the record of what was verified (with checkmarks and comments as appropriate for skips). The user can review the sheet for any remaining unchecked items or comments to identify which entries need manual follow-up.
The extension will likely provide a simple alert or popup message indicating the audit is complete (for instance, "Audit complete. X records verified, Y fields skipped."). This is just an informative summary since a detailed report UI is deferred to a future version.
Throughout this workflow, the extension maintains a tight integration between Entrata and Google Sheets, effectively acting as a bridge that navigates Entrata and updates the sheet in real time under user supervision. All operations happen in the user’s browser context (no external servers), and the user remains in control at each verification step.
Error Handling and Fallbacks
The extension is designed to handle common error scenarios gracefully to avoid derailing the entire audit. Below are key error-handling and fallback mechanisms:
PDF Text Extraction Fallback: A critical challenge is extracting text from the lease PDF documents. If the PDF has a text layer (i.e., it’s not just a scanned image), the extension will attempt to search and read text using Entrata’s viewer. However, if readable text cannot be obtained – for example, if the PDF is a scanned image or the text layer is inaccessible due to the viewer’s limitations – the extension will flag that field for manual verification. In practice, this means the field’s checkbox remains unchecked and the user is prompted that the field could not be auto-verified. No attempt is made to download the PDF file and parse it with a library like PDF.js in v1 (this complexity is intentionally avoided in the first version). The user must manually open the document and read the value, then mark the sheet accordingly outside the extension (or rerun the extension on that field once the underlying issue is resolved, if possible).
Skip and Comment: When the user skips or the extension skips a field due to an error, the extension uses the Google Sheets API to insert a comment on that cell indicating what happened. For example, a comment might read, "Field skipped by extension – unable to find lease document." This provides context to anyone reviewing the sheet later. If the extension fails to add the comment (either due to lacking permissions or a network/API error), it will simply continue without the comment rather than interrupt the audit. The presence of an unfilled checkbox itself will signal that the field needs attention.
Next-Page and End-of-List Handling: If findNext() reaches the end of an Entrata results page and hasn’t found the target resident, it will load the next page. If it reaches the end of the final page without finding the resident, the extension knows the record is not present in Entrata (at least under the current filters). In such a case, it will log or display an error to the user (for example, "Resident John Doe (Sheet row 10) not found in Entrata – skipping this row."). It then moves on to the next row in the Google Sheet. The skipped row remains unchecked in the sheet for later review.
User Stop: The user can decide to stop the audit run at any time (for instance, if something looks wrong or if it’s taking too long). In the UI, this might be done by closing the extension popup or clicking a "Stop" button if provided. If the extension encounters a critical error (like losing access to the Google Sheet or a browser navigation failure), it will also stop and notify the user. On stopping, any current operation is aborted and no further changes are made to the Google Sheet. The sheet will reflect all verifications up to that point. Since there is no formal run summary in v1, the user would rely on the sheet’s state to see what was completed before the stop.
State Cleanup: In the event of errors or when the audit completes/stops, the extension will attempt to close any auxiliary tabs or windows it opened (such as PDF viewer windows) to return the browser to a clean state, so the user isn’t left with multiple open tabs inadvertently.
Reusability and Extensibility
A major advantage of the modular design is the ease of extending the extension to handle new cases:
To add a new audit type (for example, an audit for a different kind of checklist), a developer can create a new Audit Type Class implementing the setUp(), findNext(), and nextField() interface. This new class can then be plugged into the extension (and added to the UI audit type dropdown). It can reuse any existing column modules for fields that overlap with other audits, and define new column modules only for fields that are unique to the new audit.
To add a new field/column to verify, a developer creates a new column module file (e.g., M.js for a new Column M) with the standard run and displayData methods. This module can then be included in the audit process. If that field is relevant to multiple audit types, each audit class can invoke it by simply including that column in its sequence of checks. All audit classes share the same pool of column modules, so logic is not duplicated across audits.
The modular approach isolates changes: modifying the logic for how a particular field is verified only requires editing one module file. This reduces the risk of side-effects on other parts of the extension. For example, if the format of a lease end date in Entrata changes, the Column J module can be updated to handle the new format without needing to alter the overall audit flow or any other modules.
Context sharing is carefully managed: the context object passed into run and displayData can be extended with additional information as needed (e.g., a reference to an already-open PDF window, or the current Entrata document DOM) so that new modules have the data they need. This design ensures modules remain largely independent and only rely on the context and inputs given, which makes testing and maintaining them easier.
Overall, the extension is designed so that it can grow to accommodate multiple audit types and an expanding list of verifiable fields, all while keeping each piece of logic modular and maintainable.
Design Decisions and Constraints
The following design decisions and constraints have been established for the initial version (v1) of the extension:
Google Sheet Input: The audit Google Sheet URL (or ID) must be entered for each run via the popup. This value is not stored between sessions – users provide it each time to ensure the extension always uses an up-to-date reference and does not retain potentially sensitive information.
Sheet Format Assumption: The audit spreadsheet is expected to have a fixed header row (e.g., header is on row 8 of the sheet). All logic for reading and writing assumes that row 8 contains the column names and that data rows begin immediately below. The extension will not search for the header dynamically.
Immediate Write Strategy: Changes to the Google Sheet (checking a box or adding a comment) are applied immediately as the user confirms each field. There is no batching of updates. This simplifies implementation and provides real-time feedback in the sheet (at the expense of a slight performance hit due to many small API calls, which is acceptable for the scale of these audits).
Entrata Navigation: Entrata pages are accessed through known URLs and automated clicks. The extension directly navigates to the customers_systemxxx module page for residents, which loads the Residents list without manual intervention. This direct load speeds up the process. It’s assumed the user is already logged into Entrata; if not, they would need to log in manually before starting the audit.
Sorting of Records: To ensure the order of auditing is predictable (and to match, as closely as possible, the order of rows in the Google Sheet if the sheet is pre-sorted by name or unit), the extension sorts the resident list by name in Entrata. This way, findNext() can reliably find the next resident. (If the Google Sheet is not sorted by name, the extension will still find the correct records by search, but sorting by name in Entrata provides a consistent traversal order and is a sensible default in case of manual browsing.)
Lease Document Detection: The extension identifies the correct lease document by filename pattern. It looks for a document whose name contains the property name and the word "Lease – Signed" (or a similar pattern that indicates a signed lease PDF). This approach works across properties as long as naming conventions are consistent. In v1, this is a simple pattern match; if multiple documents match or naming differs, the extension may pick the first match or require user guidance.
PDF Viewing and Scrolling: Rather than attempting to extract text by parsing PDF files externally (which would require downloading files or advanced scripting), the extension leverages Entrata’s built-in PDF viewer interface. It programmatically uses the viewer’s search function to jump to relevant text (like "Start Date", "Rent Amount", etc.). If text is found, Entrata’s viewer will typically highlight it. The extension may scroll the viewer to ensure that context around the found term is visible to the user. This design choice (using scrolling and the native highlight) is made to avoid complex PDF parsing logic in v1. It does mean that if Entrata’s viewer cannot highlight (as in scanned documents), the extension falls back to manual verification.
User Guidance over Full Automation: The extension is intentionally user-in-the-loop. Each field verification requires user confirmation. This design mitigates the risk of false positives/negatives in automated checking. It acknowledges that lease documents can be inconsistent, and a human should make the final call if something looks off. In future versions, more automation may be introduced for fields that are consistently formatted, but v1 errs on the side of caution.
No Post-Run Summary UI: There is no comprehensive summary dialog or report generated at the end of the run in this version. The expectation is that the Google Sheet itself (with its updated checkboxes and comments) serves as the record of what was done. A future version might include a summary screen or an exportable report of all discrepancies found, but for now this is out of scope.
Technology Stack: The extension is implemented in plain JavaScript (ES2022) without TypeScript. This decision was made to reduce initial complexity and setup overhead. All code runs within the extension’s context (popup script, background script, content scripts for Entrata pages as needed). Standard Chrome Extension technologies (Manifest v3, etc.) are used. There is no reliance on external libraries for core functionality except the Google Sheets API for which Google’s provided libraries or fetch calls to their endpoints are used.
By adhering to these design decisions, the project maintains clarity on what is in scope for v1 and ensures a stable, focused implementation. These constraints can be revisited in future iterations as the extension is expanded or refined.