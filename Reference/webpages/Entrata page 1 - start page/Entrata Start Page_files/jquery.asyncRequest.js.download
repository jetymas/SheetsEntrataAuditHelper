/*
* jQuery Asynchronous Request Plugin
*
* Copyright (c) 2014 - Property Solutions, International
* Author: David Merriman
*
* This plugin makes it possible to make long-running requests to URLs without
* worrying about timeouts, and without causing problems for file download
* requests that result in a file download.
*
* When using this plugin, the initial request to url should return immediately
* with a JSON object containing, at minimum:
*   token: some unique identifier for the request
*   url: the url which can be polled for request completion
* Additional information such as a status, start time, progress, projected end
* time, etc. may be included as needed by your callbacks.
*
* When the request is complete, accessing the polling URL should return the
* actual requested data. It *MUST* also set a cookie with the name being
* the token, and the value being 1. Otherwise, the polling will not stop and
* the success callback will not be called. In the case of a file, the success
* handler will be called with an empty response, and the browser will handle
* the file. Otherwise, the success handler will be called with the entire
* response.
*
* Inspired by https://github.com/johnculviner/jquery.fileDownload
*/

(function( $, window ) {

$.extend({
	asyncRequest: function( options ) {

		var settings = $.extend({
			url:				'',
			start:				function( url ) { },
			update:				function( url, response ) { },
			success:			function( url, response ) { },
			error:				function( url, response ) { },
			method:				'GET',
			data:				null,
								// 1 second to account for initial latency, every half second until 5 seconds, every second until 10 seconds, 2.5 until 20, 5 seconds until 1 minute total, then 10 seconds 3 times and finally 30 seconds
			interval:			[ 1000, 500, 500, 500, 500, 500, 500, 500, 500, 1000, 1000, 1000, 1000, 1000, 2500, 2500, 2500, 2500, 5000, 5000, 5000, 5000, 5000, 5000, 10000, 10000, 10000, 30000 ],
			isFile:				true
		}, options);

		if( false === Array.isArray( settings.interval ) ) {
			settings.interval = [ settings.interval ];
		}

		var deferred = new $.Deferred();

		var internalCallbacks = {
			onStart: function( url ) {
				settings.start( url );
			},

			onUpdate: function( url, response ) {
				settings.update( url, response );
			},

			onSuccess: function( url, response ) {
				settings.success( url, response );
				deferred.resolve( url, response );
			},

			onError: function( url, response ) {
				settings.error( url, response );
				deferred.reject( url, response );
			}
		};

		internalCallbacks.onStart( settings.url );

		var $iframe, iteration = 0;

		$.ajax({
			url: settings.url,
			type: settings.method,
			data: settings.data,

			success: function( data, status, xhr ) {
				try{
					var jsonData = $.isPlainObject( data ) ? data : JSON.parse( data );

					if( jsonData.url && jsonData.token ) {
						var newUrl = jsonData.url;
						var token = jsonData.token;
						internalCallbacks.onUpdate( newUrl, jsonData );

						function checkUpdateRequest() {
						if( false == settings.isFile ) {
							function checkRequestComplete() {
								iteration = Math.min( iteration + 1, settings.interval.length - 1 );
								$.ajax({
									url: newUrl,
									method: settings.method,
									success: function( data, status, xhr ) {
										try{
											var jsonResponseData = JSON.parse( data );
											if( jsonResponseData.isLargeReport ) {
												internalCallbacks.onUpdate( newUrl, data );
												settings.isFile = true;
												checkUpdateRequest();
												return;
											}
										} catch( e ) {
											// do nothing continue execution
										}
										if( -1 != document.cookie.indexOf( token + '=1' ) ) {
											// The presence of the cookie indicates a successful request
											var cookieData = token + '=; expires=' + new Date(0).toUTCString();
											document.cookie = cookieData;
											internalCallbacks.onSuccess( newUrl, data );
										} else {
											// The webserver may have sent a JSON as text/html, so we have to try to parse it as such first
											// Of course, if jQuery already did so, don't do it again!
											try{
												var jsonData = $.isPlainObject( data ) ? data : JSON.parse( data );
												if( jsonData.token && jsonData.url ) {
													internalCallbacks.onUpdate( newUrl, jsonData );
													setTimeout( checkRequestComplete, settings.interval[iteration] );
												} else {
													internalCallbacks.onError( newUrl, jsonData );
												}
											} catch( e ) {
												internalCallbacks.onError( newUrl, data );
											}
										}
									},
									error: function( xhr, status, error ) {
										internalCallbacks.onError( newUrl, error );
									}
								});
							};

							setTimeout( checkRequestComplete, 100 );
						} else {
							$iframe = $( '<iframe id="' + token + '">' )
								.hide()
								.prop( 'src', newUrl )
								.appendTo( 'body' );

							function getiframeDocument( $iframe ) {
								var iframeDoc = $iframe[0].contentWindow || $iframe[0].contentDocument;
								if( iframeDoc.document ) {
									iframeDoc = iframeDoc.document;
								}
								return iframeDoc;
							};

							function checkFileRequestComplete() {
								iteration = Math.min( iteration + 1, settings.interval.length - 1 );
								var iframeDoc = getiframeDocument( $iframe );
								if( -1 != document.cookie.indexOf( token + '=1' ) ) {
									// The presence of the cookie indicates a successful request
									var cookieData = token + '=; expires=' + new Date(0).toUTCString();
									document.cookie = cookieData;
									internalCallbacks.onSuccess( newUrl, iframeDoc && iframeDoc.body && iframeDoc.body.firstChild ? iframeDoc.body.firstChild.textContent : '' );
								} else if( !iframeDoc.body || 0 == iframeDoc.body.innerHTML.length ){
									// The request hasn't returned yet, so check back later
									setTimeout( checkFileRequestComplete, settings.interval[iteration] );
								} else {
									// The request returned a status update
									// If the request is still running, call update handler
									// Otherwise, call error handler with the result

									setTimeout( function () {
										// Using setTimeout so that IE 8-10 have time to load the entire content
										try {
											var response = JSON.parse( iframeDoc.body.firstChild.textContent );

											if( response.token && response.url ) {
												internalCallbacks.onUpdate( newUrl, iframeDoc.body.firstChild.textContent );
												iframeDoc.body.innerHTML = '';
												$iframe[0].src = $iframe[0].src;
												setTimeout( checkFileRequestComplete, settings.interval[iteration] );
											} else {
												internalCallbacks.onError( newUrl, iframeDoc.body.firstChild.textContent );
											}
										} catch ( e ) {
											internalCallbacks.onError( newUrl, iframeDoc.body.firstChild.textContent );
										}
									}, 100 );
								}
							};

							setTimeout( checkFileRequestComplete, 100 );
						}
						}
						checkUpdateRequest();
					} else {
						internalCallbacks.onError( settings.url, jsonData );
					}
				} catch( e ) {
					internalCallbacks.onError( settings.url, data );
				}
			},

			error: function( xhr, status, error ) {
				internalCallbacks.onError( settings.url, error );
			}
		});

		var promise = deferred.promise();
		promise.abort = function() {

		};
		return promise;
	}
});

})(jQuery, this);
//# sourceULR=jquery.asyncRequest.js
