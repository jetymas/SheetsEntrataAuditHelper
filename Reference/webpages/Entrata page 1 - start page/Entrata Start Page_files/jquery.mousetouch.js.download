+function($) {

    $.attrFn = $.attrFn || {};

    var ghostWait   = 500,
        ghostTimer  = null,
        _options    = {
                        moveRange: 10,
                        threshold: 300
                    },
        mtEvents	= {
						'mousetouchstart': ['mousedown', 'touchstart'],
						'mousetouchmove': ['mousemove', 'touchmove'],
						'mousetouchend': ['mouseup', 'touchend']				        
			        },
        _touchProps = ['touches', 'targetTouches', 'changedTouches'],
        touchRegx   = /^touch/,
        _data       = {},
        wasTouched  = false;

    // generate normalized event data for use with mouse/touch events
    function normalizeEventData(event) {
        if( !event ) {
            return { triggeredEvent: true };
        }

        var inputSrc = event,
            len = _touchProps.length,
            i = 0;

        for ( i; i < len; i++ ) {
            var curProp = _touchProps[i];

            if( event.hasOwnProperty(curProp) && event[curProp].length ) {
                inputSrc = event[curProp][0];
            }
        }

        return {
            offset: {
                x: inputSrc.pageX,
                y: inputSrc.pageY
            },
            position: {
                x: inputSrc.screenX,
                y: inputSrc.screenY
            },
            target: event.target
        };
    }

    function killGhost( e ) {
        e.stopPropagation();
        e.stopImmediatePropagation();
        e.preventDefault();
    }

    function clearTouch() {
        _data = {};
        wasTouched = false;
        $(document).off('click.ghostbuster vclick.ghostbuster');
    }

	function genEvent( evtName, evtArr ) {
		return {
	        add: function(obj) {
	            var $this = $(this),
	                handler = obj.handler,
	                toCall = {};
	
	            $this.data(evtName + 'Handlers')[obj.guid] = obj;
	
	            obj.handler = function(event) {
	                var oEvent = event.originalEvent,
	                    eventData = normalizeEventData(oEvent);
	
	                // call event for each applicable target
	                $.each($this.data(evtName + 'Handlers'), function() {
	                    if( !this.selector ) {
	                        if( $this[0] == event.target || $this.has(event.target).length > 0 ) {
                                toCall[event.target] = { event: event, data: eventData };
	                        }
	                    } else {
	                        $(this.selector, $this).each(function() {
	                            if( this == event.target  || $(this).has(event.target).length > 0 ) {
	                                toCall[event.target] = { event: event, data: eventData };
	                            }
	                        });
	                    }
	                });
	                
                    for ( var key in toCall ) {
	                    handler.call(this, toCall[key].event, toCall[key].data);
	                }
	            };
	        },
	
	        handler: function(event) {
	            var oType = event.type;
	            event.type = evtName;
	            // for jQuery < 1.8.2
	            $.event.handle.apply(this, arguments);
	            // for jQuery 1.9+
	            //$.event.trigger.call(this, event, {}, this, true);
	            event.type = oType;
	        },
	
	        setup: function(data, namespaces, evtHandle) {
	            var $this = $(this);
	
	            if( !$this.data(evtName + 'Handlers') ) {
	                $this
	                    .data(evtName + 'Handlers', {})
	                    .on(evtArr[1], $.event.special[evtName].handler)
	                    .on(evtArr[0], $.event.special[evtName].handler);
	            }
	        },
	
	        remove: function(obj) {
	            delete $(this).data(evtName + 'Handlers')[obj.guid];
	        },
	
	        teardown: function(obj) {
	            $(this)
	                .removeData(evtName + 'Handlers')
	                .off(evtArr[1], $.event.special[evtName].handler)
	                .off(evtArr[0], $.event.special[evtName].handler);
	        }
	    };
	}

    // Add Event shortcuts (for use without the .on() api)
    $.each(['mousetouchstart', 'mousetouchmove', 'mousetouchend', 'clickortap'], function (i, name) {
        $.fn[name] = function(fn) {
            return fn ? this.on(name, fn) : this.trigger(name);
        };

        $.attrFn[name] = true;
    });

    // mousetouch events
    for ( var key in mtEvents ) {
	    $.event.special[key] = genEvent(key, mtEvents[key]);
    }
	$.event.special.mousetouchstart = genEvent('mousetouchstart', ['mousedown', 'touchstart']);
	$.event.special.mousetouchmove = genEvent('mousetouchmove', ['mousemove', 'touchmove']);
	$.event.special.mousetouchend = genEvent('mousetouchend', ['mouseup', 'touchend']);

    // More complex Click/Tap event
    // Utility methods for default options object
    // getter method for _options
    $.getClickOrTapOption = function( opt ) { return _options[opt]; };
    // setter method to cahnge the tap threshold if needed
    $.setClickOrTapOption = function( opt, val ) { _options[opt] = val; };

    $.event.special.clickortap = {
        add: function(obj) {
            var $this = $(this),
                handler = obj.handler;

            $this.data('clickortapHandlers')[obj.guid] = obj;

            obj.handler = function(event) {
                var data        = $this.data('clickortapHandlers'),
                    oEvent      = event.originalEvent,
                    evtType     = oEvent && oEvent.type,
                    isClick     = event.isTrigger ? true : evtType == 'click',
                    isTap       = touchRegx.test(evtType),
                    eventData   = oEvent ? normalizeEventData(oEvent) : {},
                    noPrevent   = event.data && event.data.noPrevent,
                    validClick  = false,
                    validTap    = false,
                    toCall		= {};

                // if from touchend, determine if it was a taphold or scroll
                if( isTap ) {
                    var end = Date.now();
                    _data.hasMoved = Math.abs(oEvent.changedTouches[0].pageX - _data.startX) > _options.moveRange || Math.abs(oEvent.changedTouches[0].pageY - _data.startY) > _options.moveRange;
                    _data.isTaphold = event.target != _data.target || ( end - _data.startT > _options.threshold );
                }

                // check if it was a valid click or tap
                validClick = isClick && !wasTouched && !_data.isTaphold && !_data.hasMoved;
                validTap = isTap && wasTouched && _data.isTaphold === false && _data.hasMoved === false;

                // only run the handler for valid events
                if( validClick || validTap ) {
                    // if from a tap, keep the touch data around for a bit
                    // to prevent ghost clicks from occurring
                    if( validTap ) {
                        ghostTimer && clearTimeout(ghostTimer);
                        ghostTimer = setTimeout(clearTouch, ghostWait);

                        if( !noPrevent ) {
                            $(document).on('click.ghostbuster vclick.ghostbuster', killGhost);
                        }
                    }

                    // fire all applicable listeners
                    $.each(data, function() {
                        if( !this.selector ) {
                            if( $this[0] == event.target || $this.has(event.target).length > 0 ) {
                                toCall[event.target] = { event: event, data: eventData };
                            }
                        } else {
                            $(this.selector, $this).each(function() {
                                if( this == event.target || $this.has(event.target).length > 0 ) {
                                    toCall[event.target] = { event: event, data: eventData };
                                }
                            });
                        }
                    });
                    
                    for ( var key in toCall ) {
	                    handler.call(this, toCall[key].event, toCall[key].data);
                    }
                }
            };
        },

        handler: function( event ) {
            var oType = event.type;
            event.type = 'clickortap';
            // for jQuery < 1.8.2
            $.event.dispatch.apply(this, arguments);
            // for jQuery 1.9+
            //$.event.trigger.call(this, event, {}, this, true);
            event.type = oType;
        },

        setup: function(data, namespaces, evtHandle) {
            var $this = $(this);

            if( !$this.data('clickortapHandlers') ) {
                $this
                    .data('clickortapHandlers', {})
                    .on('touchstart', $.event.special.clickortap.touchstart)
                    .on('touchend touchcancel', $.event.special.clickortap.handler)
                    .on('click', $.event.special.clickortap.handler);
            }
        },

        remove: function(obj) {
            delete $(this).data('clickortapHandlers')[obj.guid];
        },

        teardown: function(obj) {
            $(this)
                .removeData('clickortapHandlers')
                .off('touchstart', $.event.special.clickortap.touchstart)
                .off('touchend touchcancel', $.event.special.clickortap.handler)
                .off('click', $.event.special.clickortap.handler);
        },

        touchstart: function(event) {
            // clear the ghost timer if need
            ghostTimer && clearTimeout(ghostTimer);
            // set touch data
            wasTouched = true;

            _data = {
                startT: Date.now(),
                startX: event.originalEvent.targetTouches[0].pageX,
                startY: event.originalEvent.targetTouches[0].pageY,
                target: event.target
            };
        },

        trigger: function(event) {
            // clear the touch data because we'll always use 'click' for triggering
            clearTouch();
        }
    };

}( jQuery );